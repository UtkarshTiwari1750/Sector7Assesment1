<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TriX Game Platform - Play & Earn</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 3em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        font-size: 1.2em;
        opacity: 0.9;
      }

      .game-flow {
        display: grid;
        grid-template-columns: 1fr 2fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .sidebar {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .card {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .card h3 {
        color: #ffd700;
        margin-bottom: 15px;
        border-bottom: 2px solid #ffd700;
        padding-bottom: 5px;
      }

      input,
      button,
      select {
        width: 100%;
        padding: 12px;
        margin: 8px 0;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        box-sizing: border-box;
      }

      input,
      select {
        background: rgba(255, 255, 255, 0.9);
        color: #333;
      }

      button {
        background: linear-gradient(45deg, #ff6b6b, #ffa726);
        color: white;
        cursor: pointer;
        font-weight: bold;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      button:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
      }

      .status {
        margin-top: 10px;
        padding: 10px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.3);
        font-family: monospace;
        font-size: 12px;
        word-break: break-all;
      }

      .wallet-info {
        background: rgba(0, 255, 0, 0.1);
        border: 1px solid rgba(0, 255, 0, 0.3);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
      }

      .balance-row {
        display: flex;
        justify-content: space-between;
        margin: 5px 0;
      }

      .connected {
        color: #00ff00;
      }
      .disconnected {
        color: #ff6b6b;
      }

      /* Game Arena Styles */
      .game-arena {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        padding: 20px;
        text-align: center;
      }

      .game-status {
        font-size: 1.5em;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(255, 215, 0, 0.2);
        border-radius: 10px;
        border-left: 4px solid #ffd700;
      }

      .matchmaking-section {
        margin-bottom: 30px;
      }

      .stake-selector {
        display: flex;
        gap: 10px;
        margin: 15px 0;
      }

      .stake-btn {
        flex: 1;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid transparent;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .stake-btn:hover,
      .stake-btn.selected {
        border-color: #ffd700;
        background: rgba(255, 215, 0, 0.2);
      }

      .tic-tac-toe-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
        width: 300px;
        height: 300px;
        margin: 20px auto;
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        border-radius: 10px;
      }

      .tic-tac-toe-cell {
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        font-size: 2em;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s;
      }

      .tic-tac-toe-cell:hover:not(.occupied) {
        background: rgba(255, 215, 0, 0.3);
        transform: scale(1.05);
      }

      .tic-tac-toe-cell.occupied {
        cursor: not-allowed;
      }

      .tic-tac-toe-cell.x {
        color: #ff6b6b;
      }

      .tic-tac-toe-cell.o {
        color: #4ecdc4;
      }

      .game-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 20px;
      }

      .player-card {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 10px;
        text-align: center;
      }

      .player-card.active {
        border: 2px solid #ffd700;
        background: rgba(255, 215, 0, 0.1);
      }

      .player-card.winner {
        border: 2px solid #00ff00;
        background: rgba(0, 255, 0, 0.1);
      }

      .tx-link {
        color: #ffd700;
        text-decoration: none;
        word-break: break-all;
      }

      .tx-link:hover {
        text-decoration: underline;
      }

      .hidden {
        display: none;
      }

      .queue-status {
        background: rgba(255, 165, 0, 0.2);
        border: 1px solid #ffa500;
        padding: 15px;
        border-radius: 8px;
        margin: 15px 0;
        text-align: center;
      }

      .pulse {
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .leaderboard-mini {
        max-height: 200px;
        overflow-y: auto;
      }

      .leaderboard-mini table {
        width: 100%;
        border-collapse: collapse;
      }

      .leaderboard-mini th,
      .leaderboard-mini td {
        padding: 8px;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        font-size: 12px;
      }

      .event-log {
        max-height: 150px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.2);
        padding: 10px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 11px;
      }

      .event-item {
        margin-bottom: 5px;
        padding: 5px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
      }

      @media (max-width: 1200px) {
        .game-flow {
          grid-template-columns: 1fr;
        }

        .sidebar {
          grid-row: 3;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üéÆ TriX Gaming Platform</h1>
        <p>Play Tic-Tac-Toe ‚Ä¢ Stake GT Tokens ‚Ä¢ Win Big</p>
      </div>

      <div class="game-flow">
        <!-- Left Sidebar -->
        <div class="sidebar">
          <!-- Wallet & Balance -->
          <div class="card">
            <h3>üí≥ Wallet & Balance</h3>
            <div class="wallet-info">
              <div class="balance-row">
                <span>Status:</span>
                <span id="walletStatus" class="disconnected">Disconnected</span>
              </div>
              <div class="balance-row">
                <span>Address:</span>
                <span id="walletAddress">-</span>
              </div>
              <div class="balance-row">
                <span>GT Balance:</span>
                <span id="gtBalance">-</span>
              </div>
              <div class="balance-row">
                <span>USDT Balance:</span>
                <span id="usdtBalance">-</span>
              </div>
            </div>
            <button id="connectBtn" onclick="connectWallet()">Connect MetaMask</button>
          </div>

          <!-- Buy Tokens -->
          <div class="card">
            <h3>üí∞ Get Tokens</h3>
            <button onclick="getUSDTFromFaucet()" id="faucetBtn" disabled>Get 1000 USDT</button>
            <input
              type="number"
              id="usdtAmount"
              placeholder="USDT Amount"
              step="0.000001"
              min="0"
            />
            <button onclick="buyGT()" id="buyBtn" disabled>Buy GT Tokens</button>
            <div class="status" id="tokenStatus">Connect wallet first</div>
          </div>

          <!-- Mini Leaderboard -->
          <div class="card">
            <h3>üèÜ Top Players</h3>
            <div class="leaderboard-mini" id="miniLeaderboard">
              <table>
                <thead>
                  <tr>
                    <th>Player</th>
                    <th>Wins</th>
                    <th>GT Won</th>
                  </tr>
                </thead>
                <tbody id="miniLeaderboardBody">
                  <tr>
                    <td colspan="3" style="text-align: center; color: #ccc">Loading...</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- Main Game Arena -->
        <div class="game-arena">
          <div class="game-status" id="gameStatus">
            üéØ Connect wallet and get tokens to start playing!
          </div>

          <!-- Matchmaking Section -->
          <div class="matchmaking-section" id="matchmakingSection">
            <h3>üéÆ Find Match</h3>
            <p>Choose your stake amount and find an opponent:</p>

            <div class="stake-selector">
              <div class="stake-btn" data-stake="1">
                <div>1 GT</div>
                <small>Beginner</small>
              </div>
              <div class="stake-btn" data-stake="5">
                <div>5 GT</div>
                <small>Standard</small>
              </div>
              <div class="stake-btn" data-stake="10">
                <div>10 GT</div>
                <small>High Stakes</small>
              </div>
              <div class="stake-btn" data-stake="25">
                <div>25 GT</div>
                <small>Pro</small>
              </div>
            </div>

            <button id="findMatchBtn" onclick="findMatch()" disabled>Find Match</button>
            <button id="cancelMatchBtn" onclick="cancelMatch()" disabled class="hidden">
              Cancel Search
            </button>

            <div id="queueStatus" class="hidden"></div>
          </div>

          <!-- Game Board Section -->
          <div class="game-board-section hidden" id="gameBoardSection">
            <div class="tic-tac-toe-board" id="gameBoard">
              <!-- Generated by JavaScript -->
            </div>

            <div class="game-info">
              <div class="player-card" id="player1Card">
                <h4>Player 1 (X)</h4>
                <div id="player1Address">-</div>
                <div id="player1Status">Waiting...</div>
              </div>

              <div class="player-card" id="player2Card">
                <h4>Player 2 (O)</h4>
                <div id="player2Address">-</div>
                <div id="player2Status">Waiting...</div>
              </div>
            </div>

            <div id="gameResult" class="hidden">
              <h3 id="resultText"></h3>
              <div id="payoutInfo"></div>
              <button onclick="playAgain()">Play Again</button>
            </div>
          </div>
        </div>

        <!-- Right Sidebar -->
        <div class="sidebar">
          <!-- Game Stats -->
          <div class="card">
            <h3>üìä Game Stats</h3>
            <div class="balance-row">
              <span>Active Games:</span>
              <span id="activeGames">-</span>
            </div>
            <div class="balance-row">
              <span>Players Online:</span>
              <span id="playersOnline">-</span>
            </div>
            <div class="balance-row">
              <span>In Queue:</span>
              <span id="playersInQueue">-</span>
            </div>
            <button onclick="refreshStats()">Refresh Stats</button>
          </div>

          <!-- Transaction History -->
          <div class="card">
            <h3>üìù Recent Activity</h3>
            <div id="eventLog" class="event-log">
              <div class="event-item">üéÆ Welcome to TriX Gaming!</div>
            </div>
          </div>

          <!-- Help -->
          <div class="card">
            <h3>‚ùì How to Play</h3>
            <ol style="font-size: 12px; line-height: 1.4">
              <li>Connect your wallet & get tokens</li>
              <li>Choose stake amount</li>
              <li>Find a match with another player</li>
              <li>Both players stake GT tokens</li>
              <li>Play Tic-Tac-Toe</li>
              <li>Winner gets 2√ó the stake!</li>
            </ol>
          </div>
        </div>
      </div>
    </div>

    <!-- Scripts -->
    <!-- <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script> -->
    <!-- <script src="/socket.io/socket.io.js"></script> -->
    <script type="module">
      import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js";
      import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";
      // Game configuration
      const API_BASE = 'http://localhost:3000';
      const SERVER_BASE = 'http://localhost:5173'
      const LEADERBOARD_API = 'http://localhost:3001';

      const MOCK_USDT_ABI = [
        "function balanceOf(address owner) view returns (uint256)",
        "function approve(address spender, uint256 amount) returns (bool)",
        "function allowance(address owner, address spender) view returns (uint256)",
      ];


      // Socket.IO connection
      let socket = null;

      // Game state
      let provider = null;
      let signer = null;
      let userAddress = null;
      let currentMatch = null;
      let selectedStake = null;
      let gameState = null;

      // Contract instances
      let gameTokenContract = null;
      let playGameContract = null;

      // Initialize app
      window.init = async function() {
          console.log('üöÄ Initializing TriX Gaming Platform...');

          // Check for MetaMask
          if (typeof window.ethereum !== 'undefined') {
              console.log('‚úÖ MetaMask detected');
              const accounts = await window.ethereum.request({ method: 'eth_accounts' });
              if (accounts.length > 0) {
                  await connectWallet();
              }
          } else {
              console.log('‚ùå MetaMask not found');
              document.getElementById('walletStatus').textContent = 'MetaMask not installed';
              document.getElementById('connectBtn').textContent = 'Install MetaMask';
          }

          // Initialize Socket.IO
          initializeSocket();

          // Setup stake selector
          setupStakeSelector();

          // Initialize game board
          initializeGameBoard();

          // Load initial data
          refreshStats();
          refreshLeaderboard();

          // Start periodic updates
          setInterval(refreshStats, 10000); // Every 10 seconds
          setInterval(refreshLeaderboard, 30000); // Every 30 seconds

          console.log('‚úÖ TriX Gaming Platform initialized');
      }

      // Socket.IO initialization
      window.initializeSocket = function() {
          socket = io('http://localhost:3000');

          socket.on('connect', () => {
              console.log('üîå Connected to game server');
              addEventLog('üîå Connected to game server');
          });

          socket.on('disconnect', () => {
              console.log('üîå Disconnected from game server');
              addEventLog('üîå Disconnected from game server');
          });

          socket.on('matchFound', (data) => {
              console.log('üéØ Match found!', data);
              handleMatchFound(data);
          });

          socket.on('gameStarted', (data) => {
              console.log('üéÆ Game started!', data);
              handleGameStarted(data);
          });

          socket.on('gameMove', (data) => {
              console.log('üéØ Move made:', data);
              handleGameMove(data);
          });

          socket.on('gameEnded', (data) => {
              console.log('üèÅ Game ended:', data);
              handleGameEnded(data);
          });

          socket.on('gameState', (data) => {
              console.log('üìä Game state update:', data);
              // Call appropriate handler functions based on game state
              if (data.gameState) {
                  gameState = data.gameState;
                  updateGameBoard(gameState);
                  updatePlayerCards(gameState);
              }
          });
      }

      // Wallet connection
      window.connectWallet =async function () {
          try {
              if (typeof window.ethereum === 'undefined') {
                  alert('Please install MetaMask!');
                  return;
              }

              await window.ethereum.request({ method: 'eth_requestAccounts' });
              provider = new ethers.providers.Web3Provider(window.ethereum);
              signer = provider.getSigner();
              userAddress = await signer.getAddress();

              // Update UI
              document.getElementById('walletStatus').textContent = 'Connected';
              document.getElementById('walletStatus').className = 'connected';
              document.getElementById('walletAddress').textContent = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
              document.getElementById('connectBtn').textContent = 'Connected';
              document.getElementById('connectBtn').disabled = true;

              // Enable buttons
              document.getElementById('faucetBtn').disabled = false;
              document.getElementById('buyBtn').disabled = false;

              // Load balances
              await updateGTBalance();
              await updateUSDTBalance();

              // Update game status
              document.getElementById('gameStatus').innerHTML = 'üéØ Choose your stake and find a match!';

              addEventLog('‚úÖ Wallet connected: ' + userAddress);

              // Listen for account changes
              window.ethereum.on('accountsChanged', async (accounts) => {
                  if (accounts.length === 0) {
                      disconnectWallet();
                  } else {
                      await connectWallet();
                  }
              });

          } catch (error) {
              console.error('Connection failed:', error);
              addEventLog('‚ùå Wallet connection failed: ' + error.message);
          }
      }

      // Update balances
      window.updateGTBalance = async function() {
          try {
              if (!userAddress) return;

              const response = await fetch(`${API_BASE}/balance/${userAddress}`);
              if (response.ok) {
                  const data = await response.json();
                  document.getElementById('gtBalance').textContent = `${parseFloat(data.balance).toFixed(2)} GT`;

                  // Enable find match if user has enough GT for selected stake
                  checkCanPlay();
              } else {
                  document.getElementById('gtBalance').textContent = 'Error';
              }
          } catch (error) {
              console.error('GT balance update failed:', error);
              document.getElementById('gtBalance').textContent = 'Error';
          }
      }

      window.updateUSDTBalance = async function() {
          try {
              if (!userAddress) return;

              const response = await fetch(`${API_BASE}/usdt-balance/${userAddress}`);
              if (response.ok) {
                  const data = await response.json();
                  
                  // Update USDT balance
                  const usdtBalance = parseFloat(data.usdt.balance).toFixed(2);
                  document.getElementById('usdtBalance').textContent = `${usdtBalance} USDT`;
                  
                  // Update GT balance (using the combined endpoint data)
                  const gtBalance = parseFloat(data.gt.balance).toFixed(2);
                  document.getElementById('gtBalance').textContent = `${gtBalance} GT`;
                  
                  // Enable/disable buttons based on GT balance
                  checkCanPlay();
              } else {
                  document.getElementById('usdtBalance').textContent = 'Error';
                  document.getElementById('gtBalance').textContent = 'Error';
              }
          } catch (error) {
              console.error('Balance update failed:', error);
              document.getElementById('usdtBalance').textContent = 'Error';
              document.getElementById('gtBalance').textContent = 'Error';
          }
      }

      // Token operations
        window.getUSDTFromFaucet = async function() {
          try {
              document.getElementById('faucetBtn').disabled = true;
              document.getElementById('tokenStatus').textContent = 'üîÑ Getting USDT from faucet...';

              const response = await fetch(`${API_BASE}/faucet/usdt`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                      address: userAddress,
                      amount: "1000"
                  })
              });

              const data = await response.json();

              if (response.ok) {
                  document.getElementById('tokenStatus').textContent = `‚úÖ Received ${data.amount} USDT!`;
                  addEventLog(`üí∞ Received ${data.amount} USDT from faucet`);
                  setTimeout(updateUSDTBalance, 3000);
              } else {
                  document.getElementById('tokenStatus').textContent = `‚ùå Faucet failed: ${data.error}`;
              }

          } catch (error) {
              console.error('Faucet failed:', error);
              document.getElementById('tokenStatus').textContent = `‚ùå Faucet failed: ${error.message}`;
          } finally {
              document.getElementById('faucetBtn').disabled = false;
          }
      }

      window.buyGT = async function() {
          const usdtAmount = document.getElementById('usdtAmount').value;
          if (!usdtAmount || parseFloat(usdtAmount) <= 0) {
              document.getElementById('tokenStatus').textContent = 'Please enter a valid USDT amount';
              return;
          }

          try {
              document.getElementById('buyBtn').disabled = true;
              document.getElementById('tokenStatus').textContent = 'üîÑ Processing purchase...';

                          // Get contract addresses
            const contractResponse = await fetch(`${SERVER_BASE}/contracts`);
          const contracts = await contractResponse.json();
                      // Step 1: Check current allowance
          // document.getElementById("buyStatus").textContent = "üîÑ Checking USDT allowance...";
          const allowanceResponse = await fetch(`${SERVER_BASE}/allowance/${userAddress}`);
          const allowanceData = await allowanceResponse.json();
          
          const requiredAmount = parseFloat(usdtAmount);
          const currentAllowance = parseFloat(allowanceData.allowance);
          
          // Step 2: Approve USDT if needed
          if (currentAllowance < requiredAmount) {
            // document.getElementById("buyStatus").textContent = "üîÑ Approving USDT spending...";
            addEventLog(`üìù Approving ${usdtAmount} USDT for TokenStore`);
            
            try {
              const usdtContract = new ethers.Contract(contracts.mockUSDT, MOCK_USDT_ABI, signer);
              const usdtAmountWei = ethers.utils.parseUnits(usdtAmount, 6);
              
              addEventLog(`üîç Debug - TokenStore address: ${contracts.tokenStore}`);
              addEventLog(`üîç Debug - Amount to approve: ${usdtAmountWei.toString()}`);
              
              const approveTx = await usdtContract.approve(contracts.tokenStore, usdtAmountWei);
              // document.getElementById("buyStatus").textContent = `üîÑ Approval transaction sent: ${approveTx.hash}`;
              
              await approveTx.wait();
              addEventLog(`‚úÖ USDT approval confirmed: ${approveTx.hash}`);
              
              // Verify approval worked
              const newAllowance = await usdtContract.allowance(userAddress, contracts.tokenStore);
              addEventLog(`üîç New allowance: ${ethers.utils.formatUnits(newAllowance, 6)} USDT`);
            } catch (error) {
              addEventLog(`‚ùå Approval failed: ${error.message}`);
              throw error;
            }
          } else {
            addEventLog(`‚úÖ Sufficient USDT allowance already exists`);
          }
          
          // Step 3: Purchase GT tokens
          // document.getElementById("buyStatus").textContent = "üîÑ Purchasing GT tokens...";


              const response = await fetch(`${SERVER_BASE}/purchase?amount=${usdtAmount}`);
              const data = await response.json();

              if (response.ok) {
                  document.getElementById('tokenStatus').textContent = `‚úÖ Purchase successful!`;
                  addEventLog(`üí∞ Purchased ${usdtAmount} USDT worth of GT tokens`);

                  setTimeout(() => {
                      updateGTBalance();
                      updateUSDTBalance();
                  }, 3000);

                  document.getElementById('usdtAmount').value = '';
              } else {
                  document.getElementById('tokenStatus').textContent = `‚ùå Purchase failed: ${data.error}`;
              }

          } catch (error) {
              console.error('Purchase failed:', error);
              document.getElementById('tokenStatus').textContent = `‚ùå Purchase failed: ${error.message}`;
          } finally {
              document.getElementById('buyBtn').disabled = false;
          }
      }

      // Stake selection
      window.setupStakeSelector = function() {
          const stakeButtons = document.querySelectorAll('.stake-btn');
          stakeButtons.forEach(btn => {
              btn.addEventListener('click', () => {
                  // Remove previous selection
                  stakeButtons.forEach(b => b.classList.remove('selected'));
                  // Select current
                  btn.classList.add('selected');
                  selectedStake = btn.dataset.stake;

                  checkCanPlay();
                  console.log('üéØ Selected stake:', selectedStake, 'GT');
              });
          });
      }

      // Helper function to check if user can play based on GT balance
      function checkCanPlay() {
          const findBtn = document.getElementById('findMatchBtn');
          const buyBtn = document.getElementById('buyBtn');
          const faucetBtn = document.getElementById('faucetBtn');

          if (!userAddress) {
              if (findBtn) findBtn.disabled = true;
              if (buyBtn) buyBtn.disabled = true;
              if (faucetBtn) faucetBtn.disabled = true;
              return;
          }

          // Enable buy and faucet buttons when wallet is connected
          if (buyBtn) buyBtn.disabled = false;
          if (faucetBtn) faucetBtn.disabled = false;

          if (!selectedStake) {
              if (findBtn) findBtn.disabled = true;
              return;
          }

          // Check if user has enough GT balance for the selected stake
          const gtBalanceText = document.getElementById('gtBalance').textContent;
          if (gtBalanceText === '-' || gtBalanceText === 'Error') {
              if (findBtn) findBtn.disabled = true;
              return;
          }

          const currentBalance = parseFloat(gtBalanceText.replace(' GT', '')) || 0;
          const requiredStake = parseFloat(selectedStake);

          if (findBtn) {
              if (currentBalance >= requiredStake) {
                  findBtn.disabled = false;
                  findBtn.textContent = `Find Match (${selectedStake} GT)`;
              } else {
                  findBtn.disabled = true;
                  findBtn.textContent = `Insufficient GT (need ${selectedStake})`;
              }
          }
      }

      // Matchmaking
      window.findMatch = async function() {
          if (!selectedStake || !userAddress) {
              alert('Please select a stake amount and connect wallet');
              return;
          }

          try {
              document.getElementById('findMatchBtn').disabled = true;
              document.getElementById('gameStatus').innerHTML = 'üîç Searching for opponent...';

              const response = await fetch(`${API_BASE}/matchmaking/join`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                      address: userAddress,
                      stake: selectedStake,
                      socketId: socket.id
                  })
              });

              const data = await response.json();

              if (response.ok) {
                  if (data.matchId) {
                      // Match found immediately
                      console.log('üéØ Instant match found!', data);
                      currentMatch = data.matchId;
                      handleMatchFound({ matchId: data.matchId, opponent: data.opponent });
                  } else {
                      // Added to queue
                      showQueueStatus(data);
                      document.getElementById('cancelMatchBtn').classList.remove('hidden');
                      document.getElementById('findMatchBtn').classList.add('hidden');
                  }

                  addEventLog(`üéØ Searching for match with ${selectedStake} GT stake`);
              } else {
                  document.getElementById('gameStatus').innerHTML = `‚ùå Matchmaking failed: ${data.error}`;
                  document.getElementById('findMatchBtn').disabled = false;
              }

          } catch (error) {
              console.error('Matchmaking failed:', error);
              document.getElementById('gameStatus').innerHTML = `‚ùå Matchmaking failed: ${error.message}`;
              document.getElementById('findMatchBtn').disabled = false;
          }
      }

      window.cancelMatch = async function() {
          try {
              const response = await fetch(`${API_BASE}/matchmaking/leave`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ address: userAddress })
              });

              if (response.ok) {
                  document.getElementById('gameStatus').innerHTML = 'üéØ Choose your stake and find a match!';
                  document.getElementById('queueStatus').classList.add('hidden');
                  document.getElementById('cancelMatchBtn').classList.add('hidden');
                  document.getElementById('findMatchBtn').classList.remove('hidden');
                  document.getElementById('findMatchBtn').disabled = false;

                  addEventLog('‚ùå Cancelled matchmaking');
              }
          } catch (error) {
              console.error('Cancel match failed:', error);
          }
      }

      function showQueueStatus(data) {
          const queueDiv = document.getElementById('queueStatus');
          queueDiv.className = 'queue-status pulse';
          queueDiv.innerHTML = `
              <div>üîç Searching for opponent...</div>
              <div>Position in queue: ${data.position}</div>
              <div>Players waiting: ${data.queueSize}</div>
          `;
          queueDiv.classList.remove('hidden');
      }

      // Game handlers
      function handleMatchFound(data) {
          console.log('üéØ Match found handler:', data);
          currentMatch = data.matchId;

          // Hide matchmaking, show game
          document.getElementById('matchmakingSection').classList.add('hidden');
          document.getElementById('gameBoardSection').classList.remove('hidden');

          document.getElementById('gameStatus').innerHTML = `üéÆ Match found! Waiting for both players to stake...`;

          // Join the game room
          socket.emit('joinGame', {
              matchId: currentMatch,
              playerAddress: userAddress
          });

          addEventLog(`üéØ Match found! Opponent: ${data.opponent.slice(0, 6)}...${data.opponent.slice(-4)}`);

          // Auto-stake after a short delay to let user see the match
          setTimeout(() => stakeInGame(), 2000);
      }

      window.stakeInGame = async function() {
          if (!currentMatch || !selectedStake) return;

          try {
              document.getElementById('gameStatus').innerHTML = 'üîÑ Staking your GT tokens...';

              // First approve the spending
              if (!gameTokenContract) {
                  const response = await fetch(`${SERVER_BASE}/contracts`);
                  const contracts = await response.json();

                  gameTokenContract = new ethers.Contract(
                      contracts.gameToken,
                      ["function approve(address spender, uint256 amount) returns (bool)"],
                      signer
                  );

                  playGameContract = new ethers.Contract(
                      contracts.playGame,
                      ["function stake(bytes32 matchId) external"],
                      signer
                  );
              }

              const stakeAmount = ethers.utils.parseEther(selectedStake);

              // Approve spending
              const approveTx = await gameTokenContract.approve(playGameContract.address, stakeAmount);
              await approveTx.wait();

              addEventLog('‚úÖ Approved GT spending for staking');

              // Stake in the game
              const matchIdBytes = ethers.utils.formatBytes32String(currentMatch);
              const stakeTx = await playGameContract.stake(matchIdBytes);
              await stakeTx.wait();

              // Notify server
              socket.emit('playerStaked', {
                  matchId: currentMatch,
                  playerAddress: userAddress,
                  txHash: stakeTx.hash
              });

              document.getElementById('gameStatus').innerHTML = '‚úÖ Staked! Waiting for opponent to stake...';
              addEventLog(`‚úÖ Staked ${selectedStake} GT in match`);

              // Update balance
              setTimeout(updateGTBalance, 3000);

          } catch (error) {
              console.error('Staking failed:', error);
              document.getElementById('gameStatus').innerHTML = `‚ùå Staking failed: ${error.message}`;
              addEventLog(`‚ùå Staking failed: ${error.message}`);
          }
      }

      function handleGameStarted(data) {
          console.log('üéÆ Game started handler:', data);
          gameState = data.gameState;

          document.getElementById('gameStatus').innerHTML = 'üéÆ Game started! Make your move!';

          // Update player info
          updatePlayerCards(gameState);

          // Enable game board
          updateGameBoard(gameState);

          addEventLog('üéÆ Game started! Both players have staked.');
      }

      function updatePlayerCards(state) {
          const player1Card = document.getElementById('player1Card');
          const player2Card = document.getElementById('player2Card');

          // Update addresses
          document.getElementById('player1Address').textContent =
              `${state.player1.slice(0, 6)}...${state.player1.slice(-4)}`;
          document.getElementById('player2Address').textContent =
              `${state.player2.slice(0, 6)}...${state.player2.slice(-4)}`;

          // Update active player
          player1Card.classList.remove('active', 'winner');
          player2Card.classList.remove('active', 'winner');

          if (state.status === 'playing') {
              if (state.currentPlayer === state.player1) {
                  player1Card.classList.add('active');
              } else {
                  player2Card.classList.add('active');
              }
          }

          // Update status
          const isPlayer1 = userAddress === state.player1;
          const isMyTurn = state.currentPlayer === userAddress;

          if (state.status === 'playing') {
              document.getElementById('player1Status').textContent =
                  state.currentPlayer === state.player1 ? 'Your turn!' : 'Waiting...';
              document.getElementById('player2Status').textContent =
                  state.currentPlayer === state.player2 ? 'Your turn!' : 'Waiting...';

              // Update main status
              if (isMyTurn) {
                  document.getElementById('gameStatus').innerHTML = `üéØ Your turn! You are ${isPlayer1 ? 'X' : 'O'}`;
              } else {
                  document.getElementById('gameStatus').innerHTML = `‚è≥ Opponent's turn... You are ${isPlayer1 ? 'X' : 'O'}`;
              }
          }
      }

      // Game board
      window.initializeGameBoard = function() {
          const board = document.getElementById('gameBoard');
          board.innerHTML = '';

          for (let i = 0; i < 9; i++) {
              const cell = document.createElement('div');
              cell.className = 'tic-tac-toe-cell';
              cell.dataset.position = i;
              cell.addEventListener('click', () => makeMove(i));
              board.appendChild(cell);
          }
      }

      function updateGameBoard(state) {
          const cells = document.querySelectorAll('.tic-tac-toe-cell');

          cells.forEach((cell, index) => {
              const value = state.board[index];
              cell.textContent = value || '';
              cell.className = 'tic-tac-toe-cell';

              if (value) {
                  cell.classList.add('occupied', value.toLowerCase());
              }
          });
      }

      async function makeMove(position) {
          if (!currentMatch || !gameState) return;

          // Check if it's player's turn
          if (gameState.currentPlayer !== userAddress) {
              alert("It's not your turn!");
              return;
          }

          // Check if cell is empty
          if (gameState.board[position] !== null) {
              alert("Cell already taken!");
              return;
          }

          try {
              const response = await fetch(`${API_BASE}/game/${currentMatch}/move`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                      player: userAddress,
                      move: { position }
                  })
              });

              const data = await response.json();

              if (!response.ok) {
                  alert(data.error);
                  return;
              }

              // Move will be broadcast via socket
              console.log('‚úÖ Move made successfully');

          } catch (error) {
              console.error('Move failed:', error);
              alert('Move failed: ' + error.message);
          }
      }

      function handleGameMove(data) {
          console.log('üéØ Game move handler:', data);
          gameState = data.gameState;

          updateGameBoard(gameState);
          updatePlayerCards(gameState);

          addEventLog(`üéØ Move made at position ${data.move.position}`);
      }

      function handleGameEnded(data) {
          console.log('üèÅ Game ended handler:', data);
          gameState = data.gameState;

          const resultDiv = document.getElementById('gameResult');
          const resultText = document.getElementById('resultText');
          const payoutInfo = document.getElementById('payoutInfo');

          updateGameBoard(gameState);

          if (data.winner) {
              const isWinner = data.winner === userAddress;
              resultText.textContent = isWinner ? 'üéâ You Won!' : 'üíî You Lost';

              // Update winner card
              if (data.winner === gameState.player1) {
                  document.getElementById('player1Card').classList.add('winner');
              } else {
                  document.getElementById('player2Card').classList.add('winner');
              }

              if (data.payoutTx) {
                  payoutInfo.innerHTML = `
                      <div>üí∞ Prize: ${parseFloat(selectedStake) * 2} GT</div>
                      <div>üîó Transaction: <a href="https://etherscan.io/tx/${data.payoutTx}" target="_blank" class="tx-link">${data.payoutTx.slice(0, 10)}...</a></div>
                  `;

                  addEventLog(`üí∞ Game ended. Winner: ${data.winner.slice(0,6)}...${data.winner.slice(-4)}`);

                  // Update balance after a delay
                  setTimeout(updateGTBalance, 3000);
              } else {
                  payoutInfo.textContent = 'Processing payout...';
              }

              document.getElementById('gameStatus').innerHTML =
                  isWinner ? 'üéâ Congratulations! You won the match!' : 'üíî Game over. Better luck next time!';

          } else {
              resultText.textContent = 'ü§ù It\'s a Draw!';
              payoutInfo.textContent = 'No payout for draws.';
              document.getElementById('gameStatus').innerHTML = 'ü§ù Game ended in a draw!';
              addEventLog('ü§ù Game ended in a draw');
          }

          resultDiv.classList.remove('hidden');
      }

      window.playAgain = function() {
          // Reset game state
          currentMatch = null;
          gameState = null;
          selectedStake = null;

          // Reset UI
          document.getElementById('matchmakingSection').classList.remove('hidden');
          document.getElementById('gameBoardSection').classList.add('hidden');
          document.getElementById('gameResult').classList.add('hidden');
          document.getElementById('gameStatus').innerHTML = 'üéØ Choose your stake and find a match!';

          // Clear selections
          document.querySelectorAll('.stake-btn').forEach(btn => btn.classList.remove('selected'));

          // Reset game board
          initializeGameBoard();

          // Reset buttons
          document.getElementById('findMatchBtn').classList.remove('hidden');
          document.getElementById('findMatchBtn').disabled = false;
          document.getElementById('cancelMatchBtn').classList.add('hidden');

          addEventLog('üéÆ Ready for another game!');
      }

      // Statistics
      window.refreshStats = async function() {
          try {
              const response = await fetch(`${API_BASE}/stats/games`);
              if (response.ok) {
                  const stats = await response.json();

                  document.getElementById('activeGames').textContent = stats.activeGames;
                  document.getElementById('playersOnline').textContent = stats.connectedPlayers;
                  document.getElementById('playersInQueue').textContent = stats.totalQueued;
              }
          } catch (error) {
              console.error('Failed to load stats:', error);
          }
      }

      window.refreshLeaderboard = async function () {
          try {
              const response = await fetch(`${LEADERBOARD_API}/leaderboard?limit=5`);
              if (response.ok) {
                  const leaderboard = await response.json();

                  const tbody = document.getElementById('miniLeaderboardBody');
                  tbody.innerHTML = '';

                  if (leaderboard.length === 0) {
                      tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; color: #ccc;">No games yet</td></tr>';
                      return;
                  }

                  leaderboard.forEach((player, index) => {
                      const row = document.createElement('tr');
                      row.innerHTML = `
                          <td>${player.address.slice(0,6)}...</td>
                          <td>${player.wins}</td>
                          <td>${parseFloat(ethers.utils.formatEther(player.gtWon || '0')).toFixed(1)}</td>
                      `;
                      tbody.appendChild(row);
                  });
              }
          } catch (error) {
              console.error('Failed to load leaderboard:', error);
          }
      }

      // Event logging
      function addEventLog(message) {
          const eventLog = document.getElementById('eventLog');
          const eventItem = document.createElement('div');
          eventItem.className = 'event-item';
          eventItem.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong> - ${message}`;

          eventLog.insertBefore(eventItem, eventLog.firstChild);

          // Keep only last 10 events
          const events = eventLog.children;
          if (events.length > 10) {
              eventLog.removeChild(events[events.length - 1]);
          }
      }

      // Initialize app when page loads
      window.addEventListener('load', init);
    </script>
  </body>
</html>
